<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MunJu TEST</title>
    <!--jquery-->
    <!-- <script src="../example/count/js/COMMON_geo.js"></script> -->
    <script src="https://code.jquery.com/jquery-latest.min.js"></script>
</head>

<script>
/* 

<단답형>
*하기 문제는 자바스크립트 or 제이쿼리를 사용하시오.
1. input:text name=chk 에 있는 value값을 배열에 담으시오.
2. input:text name=chk 에 있는 value값을 전부 더하시오.
3. input:text name=chk 에 있는 value값이 홀수인것만 출력하시오.
4. input:text name=chk 에 있는 value값이 짝수인것만 출력하시오.
5. input:text name=chk 에 있는 value값이 홀수인것만 더하시오.
6. input:text name=chk 에 있는 value값이 짝수인것만 더하시오.

<서술형>
1. 자료형에 대해 설명하시오
-변수-> 데이터의 저장을 위해 할당된 메모리 공간의 이름 -> ex)정수를 저장하려면 몇 바이트를 사용할까요?-> 4바이트의 이름은 num인 정수를 저장하고싶다 -> 자료형이 int 변수 num
-자료형은 변수의 종류를 의미하는데 변수에 값을 담기 이전에, 정수, 실수, 문자, 문자열 등 어떤 값을 지닐 수 있는지 미리정해주여야한다.
-자료형(Data Type)은 데이터를 표현하는 방법으로 시스템, 컴파일러 ,사람 등이 인식 가능한 자료형태로 컴퓨터 내에서 특정 비트들이 그룹핑 되어 연산되는 방식이다. 
-일정 크기(길이)의 메모리에 저장된 정보를 해석하는 방법.

자료형  
->정수형
       char         1byte(8bite)       -128이상 -127이하 데이터의 종류 2의8승 = 256개
       short        2byte(16bite)      -32,768이상 +32,767 이하
       int          4byte(32bite)      -2,147,483,648 이상  +2,147,483,647 이하
       long         4byte(32bite)      -2,147,483,648 이상  +2,147,483,647 이하
       long long    8byte(64bite)      -9,223,372,036,854,775,808 이상 +-9,223,372,036,854,775,807 이하

->실수형 
       float  4byte(32bite)               +- 3.4 x 10의 -37승 이상 +- 3.4 x 10의 +38승 이하
       dobule 8byte(64bite)               +- 1.7 x 10의 -307승 이상 +- 3.4 x 10의 +308승 이하
       long duble 8byte이상(64bite이상)    dobule 이상의 표현 범위


->비트는 컴퓨터가 처리할 수 있는 최소 단위로, 하나의 비트는 0 혹은 1의 값을 가지고 있음
하나의 비트로는 표현할 수 있는 영역이 0과 1뿐이므로 비트8개가 모여진게 바이트임.
비트 8개가 모이면 이진수를 이용하여 값을 2의 7승인 128개의 양수와 음수를 만들 수 있는데,
양수는 0부터 127까지 128개로 이루어지고, 음수는 -1부터 -128까지 표현할 수 있다.
숫자를 저장할 때에는 해당 자료형의 영역만큼의 영역을 사용할 수 있는데, 문자의 경우 1바이트는 영문자,
숫자, 특수문자 할 글자를 저장할 수 있는 정도의 크기이다. 2바이트는 1바이트로는 처리하기 어려운
한글, 일어, 중국어 등의 문자 하나를 저장할 수 있는 크기이다.

ex) int level;
    level = 1;

->같은 자료형이라 하더라도 사용되는 바이트 크기가 클수록 표현할 수 있는 값의 범위가 넓어진다.
->데이터의 표현방식이 다르므로 최소 둘 이상의 자료형이 필요하다. (정수자료형,실수자료형)
->메모리 공간의 적절한 사용을 위해 다양한 크기의 자료형이 필요하다. (메모리의 효율성)

2. 배열에 대해 설명하시오.
-배열(array)은 연관된 데이터를 모아 통으로 관리하기 위해 사용하는 데이터타입이다.
-변수가 하나의 데이터를 저장하기 위한 것이라면, 배열은 여러개의 데이터를 통으로 모아 하나의
변수에 저장하기 위한 것이라고 할 수 있다.

ex) var array = ['박보검','박서준','유아인']
    alert(array[0]);
    alert(array[1]);
    alert(array[2]);

-배열에 담겨있는 값을 가져올 때는 대괄호 안에 숫자를 넣고, 이 숫자는 색인(index)라고 하며
첫번째 원소를 가져오려면 대괄호 안에 0을 넣어주어야 한다. 즉 인덱스는 0부터 시작하며 인덱스 번호를 사용하여
배열에 지정된 값을 가져올 수 있다.

-만약 배열이 없다면,

    function get_members1(){
        return '박보검';
    }
    document.write(get_members1());

->하나의 함수는 하나의 값만을 반활할 수 있기 때문에 위와 같이 반환하는 함수를 만들었다. 하지만 배열을 쓰면 간단하게 만들 수 있다.

    function get_members(){
        return ['박보검','박서준','유아인'];
    }
    var members = get_members();
    document.write(members[0]);
    document.write(members[1]);
    document.write(members[2]);

-배열과 반복문이 결합 했을 때
function get_members(){
    return['whanswn','whanswn1','whanswn2'];
}
members = get_members();

for ( i = 0; i < members.length; i++){
    document.write(members[i].toUpperCase());
    document.write('<br />');
}

-members.length 는 배열에 담긴 값의 숫자를 알려준다 배열의 갯수(크기)를 의미함.
-toUpperCase()는 대문자로 변환
->배열이란 연관된 정보를 하나의 그룹으로 관리하기 위해 사용한다. 그 정보를 처리할 때에는 반복문을 이용한다.(중요)

-배열의 크기는 length를 통해 알 수 있다.

    var arr = [1,2,3,4,5];
    alert(arr.length); //5

-배열의 끝에 원소를 추가하는 방법은 push를 이용한다

    var li = ['a','b','c'];
    li.push('d');
    alert(li); //a,b,c,d

-복수의 원소를 배열에 추가 할 때에는 concat으로 전달된 값을 추가하는 명령어를 사용한다
    
    var li = ['a','b','c'];
    li = li.concat['d','e'];
    alert(li); //abcde

-배열의 시작점에 원소를 추가할 때에는 unshift,배열의 첫번째 원소로 추가시켜주고 배열의 기존 값들의 
인덱스 번호를 1씩 증가시킨다

    var li = ['a','b','c','d'];
    li.unshift('x');
    alert(li); //xabcd

-배열에서 원하는 위치에 원소를 넣고 싶다면 splice를 사용하는데, 만약 두번째 인덱스 뒤에 원소를 추가 하고 싶다고 가정한다면,
두번째 인자에 해당하는 원소의 숫자만큼 값을 배열로부터 제거한 후에 리턴한다. 그리고 세번째 원소부터 전달된 인자들을 첫번째 인자의 원소 뒤에 추가한다.

    var li = ['a','b','c','d','e'];
    li.splice(2,0,'B');
    alert(li); //abBcde

-배열에서 첫번째 원소를 제거할 때에는 shift를 사용하고, 끝점에서 제거 할때는 pop을 사용한다.

    var li = ['a','b','c','d','e'];
    li.shift();
    alert(li); //bcde

    var li = ['a','b','c','d','e'];
    li.pop();
    alert(li); //abcd

-배열의 순서를 정렬할 때에는 sort를 사용하고, 역순으로 정렬할 때(배열내 역순일때)는 reverse를 사용한다

    var li = ['c','e','a','b','d'];
    // li.sort();
    li.reverse();
    alert(li);

3. if, for문에 대해 설명하시오.
Boolean (불리언) ->false,true
-조건문이란 주어진 조건에 따라 다르게 동작하도록 할 수 있는 것인데,조건문은 if로 시작한다 뒤에 괄호 조건이 오고, 
조건이 될 수 있는 값은 Boolean이다. Boolean의 값이 true라면 조건이 담겨진 괄호 다음의 중괄호 구문이 실행된다.

if(true){
    alert('result:true');
} -> 실행결과는 그대로 출력된다. if 뒤에 true 라서
if(false){
    alert('result:true');
} ->if 뒤에 false라서 아무것도 출력되지 않는다

else가 들어간다면, 
if(true){
    alert(1);
}else{
    alert(2);
}  ->1만출력됨(true의 값만)
if(false){
    alert(1);
}else{
    alert(2);
}  ->2만 출력됨
--->if의 조건이 true라면 if 중괄호 구간이 실행되고, false라면 else이후의 중괄호 구간이 실행된다.
else는 주어진 조건이 거짓일 때 실행할 구간을 정의한다.

if(false){
    alert(1);
}else if(false){
    alert(2);
}else if(false){
    alert(3);
}else{
    alert(4);
}

-else if는 좀 더 다양한 케이스의 조건을 검사할 수 있는 기회를 제공한다. if나 else와는 다르게 여러개가 올 수 있다는 
점이 다르며 else if의 모든 조건이 false라면 else가 실행되며 else는 생략이 가능하다.

    id = prompt('이메일을 확인해주세요');
    if(id=="munju"){
        alert('이메일이 일치합니다.');
    }else{
        alert('이메일이 일치하지 않습니다.');
    }
->prompt() 구문은 사용자가 입력한 값을 가져와서 id 변수의 값으로 대입하는데, 이 값에 따른 비교문이다.

    id = prompt('아이디를 입력하세요');
    if(id==="munju"){
        password = prompt('비밀번호를 입력하세요');
        if(password==="1234"){
            alert('인증완료');
        }else{
            alert('인증실패');
        }
    }else{
        alert('아이디가 다릅니다.');
    }

->if문 안에 if문이 나오고, 사용자가 입력한 값과 아이디값이 일치하는지 확인한 후에 
일치한다면 비밀번호가 일치하는 지 확인한다. 조건문은 조건문 안에 중첩해서 사용할 수 있다.

-조건문을 좀 더 간결하고 다양한 방법으로 구사할 수 있도록 논리 연산자를 사용하는데, 
-&&은 좌항과 우항이 모두 ture 참일때만 참이 된다. (and 그리고의 개념이라 모두 충족되어야 성립)

   id = prompt('아이디를 입력하세요');
   password = prompt('비밀번호를 입력해라');
   if(id=='munju' && password == "1234"){
       alert('인증완료');
   }else{
       alert('인증실패');
   }

-중첩된 if문을 하나로 줄였고, id값이 munju이고 password의 값이 1234일때 전체가 참이 되는것이다
-||연산자는 좌우항 중에 하나라도 true이면 true가 되는 논리 연산자이다. or연산자이다.(또는)

   id = prompt('아이디를 입력하세요');
   if(id==="munju" || id==='박보검' || id==='박서준'){
       alert('인증완료');
   }else{
       alert('인증실패');
   }

-! 느낌표는 부정의 의미로 불리언의 값을 바꾼다
if(!true && !true){
    alert(1);
}

-for문
for(초기화; 반복조건; 반복될때마다 실행되는 코드){
    반복해서 실행될 코드
}

for(var i = 0; i < 10; i++){
    document.write('coding numusiru'+i+'<br/>');
}

-for문은 제일먼저 초기화를 한다 var i = 0; 인데, 변수 i의 값을 0으로 먼저 설정하고 
반복조건인 i < 10이 실행된다 i의 값은 0이므로 참이고, 반복조건이 참이면 중괄호 안의
내용이 실행된다. i의 값이 0이기 때문에 중괄호 안에 있는 텍스트가 출력된다. 
i++는 현재 i의 값에 1을 더하라는 의미로 i<10이라서 참이며, i의 값에 1을 더해서 i는 1이고,
이 과정에서 i의 값은 반복 될 때마다 1씩 증가한다. 결국 i의 값이 10이 되는 순간 i < 10 을 
충족시키지 못하기 때문에 반복문은 9까지만 출력되고 종료된다.

for (var i = 0; i < 10; i++){
    if(i==5){
        break;
    }
    document.write('jeongmalsiru'+i+'<br/>');
}
->반복작업을 중간에 중단 시키고 싶다면 break를 사용한다. i의 값이 5와 똑같다면 반복문은 
4까지만 출력되고 즉시 종료된다.

for(var i = 0; i < 10; i++){
    if(i===5){
        continue;
    }
    document.write('munju'+i+'<br/>');
}
->실행을 즉시 중단하면서 반복은 지속되게 하려면 continue를 사용하면 된다.
결과문은 5를 제외하고는 0부터 9까지 출력이 된다. i의 값이 5가 되었을 때 실행이 중단됐기 때문에
continue이후의 구문이 실행되지 않았다. 하지만 반복문은 중단 되지 않았기 때문에 나머지 결과는
조건문에 맞게 출력이 된다. 

for(var i = 0; i < 10; i++){
    for( var k = 0; k < 10; k++){
        document.write(String(i)+String(k)+'<br/>');
    }
}
->반복문 안에는 반복문을 넣을 수 있는데, 0부터 9까지의 변수 i에 순차적으로 값을 넣고, 
0부터 9까지의 변수를 k의 값에 넣는다, i와 k의 데이터 타입을 문자로 바꾸고 00부터 99까지를 화면에 출력할 수 있다.


4. <form> 태그에 대해 설명하시오.
 폼이 있는 웹페이지 방문-> 폼 내용 사용자가 입력->폼안에 있는 모든 데이터를
 웹서버로 보냄-> 웹서버는 받은 폼 데이터를 처리 하기 위해 웹프로그램으로 넘김->
 웹프로그램은 폼데이터를 처리함-> 처리결과에 따른 새로운 html 페이지를 웹서버로 보냄->
 웹서버는 받은 html페이지를 브라우저에 보냄->브라우저는 받은 html페이지를 유저에게 보여줌

 폼태그 속성
-name 폼을 식별하기 위한 이름을 지정함.
-action 폼을 전송할 서버 쪽 스크립트 파일을 지정함. html5부터는 안써도 되도록 변경되었음.
-target action에서 지정한 스크립트 파일을 현재 창이 아닌 다른 위치에 열도록 지정.
-method 폼을 서버에 전송할 http메소드를 정함. get또는 post
-accept-charset 폼 전송에 사용할 문자 인코딩 지정

폼을 구성하는 엘리먼트
-fieldset 태그는 폼 태그 안에 관련된 폼 엘리먼트들을 그룹화 할때 사용하고,
태그 하위에 legend 태그를 사용하여 그룹화한 폼 엘리먼트들의 목적에 맞게 이름을 지정한다.


<form action = "#" accept-charset="utf-8" name = "person_info" method = "get">
    <fieldset style = "width:150">
        <legend>개인 정보 입력</legend>
            이름 : <input type = "text" name = "name"/><br><br>
            나이 : <input type = "text" name = "age"/><br><br>
    </fieldset>
    <br>
    <fieldset style = "width:180; height:180">
        <legend>여가 활동</legend>
            취미 : <input type = "text" name = "hobby"/><br><br>
            특기 : <input type = "text" name = "specialty"/><br><br>
    </fieldset> 
</form>

5. get, post에 대해 설명하시오.
-form태그의 method 속성인 get과 post방식
method 속성은 폼에 전솔할 데이터 방식을 지정한다. 
get 방식은 url로 값을 받아오고 서버가 계산을 한 뒤 결과를 보여준다.
예를 들면 검색엔진이 있는데, http://search.naver.com/search.naver?query=test
의 주소를 입력하면 test에 대한 검색 결과를 알 수 있다. search.naver란 페이지에
?query=test 라는 값을 전송한 것이다. 
get방식은 주로 서버에서 받아오는 방식으로 페이지를 검색/조회 하는데 사용하는데,
url 끝에 데이터를 붙여 보내는 get방식은 데이터가 외부에 노출 되어 보안에 취약하다. 

-post 방식은 url이 노출이 되지 않고, 서버에 올리면서 수행하는 방식(글쓰기나 글삭제 등과 같이 서버의 값을
변화시키는 작업)에 사용된다. 내부적으로 보이지 않게 보낸다.http://localhost:8080/form.jsp

->http://url/list.html?id=7&pagenum=2 이게 GET방식이고, form을 이용해서 submit 형태가 POST방식이다

-> GET은 가져오는 것이고 POST는 수행하는 것이다. 
GET은 select 적인 성향을 가지고 있는데 어떤 데이터를 가져와서 보여주는 용도이지
서버의 값이나 상태등을 바꾸진 않는다. 
반면에 POST는 서버의 값이나 상태를 바꾸기 위해서 사용한다 글쓰기를 한다하면 
글의 내용이 디비에 저장되고 수정하면 디비값이 수정이 된다. 

-가져오는 곳에 GET을 사용해야하는것은 link문제 떄문인데, 웹에서 모든 리소스는 link할 수 있는
url을 가지고 있어야한다. (예를 들면 주소창의 url을 다른 유저와 공유할 수 있어야한다.)
POST를 사용할 경우에는 내부적으로 전달 되기 때문에 URL만 전달 할수 없고, 글을 저장하는 경우에는
URL을 제공할 필요가 없기 때문에 POST를 사용해도 상관이 없다.


6. parameter에 대해 설명하시오.
-파라미터는 매개변수로 넘겨지는 값(변수)와 동일하다. 
 
    function plus(A,B){
        C = A + B;
    echo C;
    }
    plus(10,20);
    echo "<br>";
    plus(100,200);
//  cf) Output one or more strings -> eho
    여기서 넘겨지는 값은 10,20,100,200인데 이게 파라미터 이다. 

7. Object에 대해 설명하시오.
객체지향 프로그래밍은 좀 더 나은 프로그램을 만들기 위한 프로그래밍 패러다임으로, 
로직을 상태와 행위로 이루어진 객체로 만드는것이다. 마치 레고 블럭처럼 조립해서
하나의 프로그램을 만드는 것을 객체지향 프로그래밍이라고 할 수 있는데, 객체 지향 프로그래밍은 객체를
만드는 것이다. 

-객체란 서로 연관된 변수와 함수를 그루핑한 그릇이라고 할 수 있다. 
객체 내의 변수를 property프로퍼티라하고 함수를 메소드라고 부른다. 

    var person = {};
    person.name = "munju";
    person.introduce = function(){
        return 'My name is'+this.name;
    }
    document.write(person.introduce());

    또는

    var person = {
        'name':'munju',
        'introduce': function(){
            return 'My name is' + this.name;
        }
    }
    document.write(person.introduce());

->만약 더 늘어나서 담을 객체가 필요하다면 계속해서 객체의 정의를 반복해야한다.
따라서 객체의 구조를 재활용할 수 있는 생성자가 필요하다. 
-생성자(constructor)는 객체를 만드는 역할을 하는 함수인데, 자바스크립트에서 함수는
재사용할 수 있는 로직의 묶음이 아니라 객체를 만드는 창조자의 역할 이라고 본다. 

    function Person(){
        var P = new Person();
        p.name = "munju";
        p.introduce = function(){
            return 'My name is' + this.name;
        }
    }
    document.write(p.introduce());

-> 함수를 호출 할 때 new를 붙이고 새로운 객체를 만든 후에 리턴한다. 

function Person(name){
    this.name = name;
    this.introduce = function(){
        return 'My name is' + this.name;
    }
}
var p1 = new Person('munju');
document.write(p1.introduce() + '<br/>');

var p2 = new Person('bogum');
document.write(p2.introduce() + '<br/>');

->생성자 내에서 객체의 프로퍼티를 정의하고 있다 이러한 작업을 초기화 라고 하며, 
이를 통해 코드의 재사용성을 높일 수 있다. 생성자함수는 일반함수와 구분 짓기 위해
첫글자를 대문자로 표시한다. 

-자바스크립트 생성자의 특징
: 일반적인 객체지향 언어에서 생성자는 클래스의 소속이다. 하지만 자바스크립트에서 
객체를 만드는 주체는 함수이며, 함수에 new를 붙이는 것을 통해서 객체를 만들수 있다는 점은
자바스크립트에서 함수의 위상을 알 수 있는 단서이며, 자바스크립트에서 추구하는 자유로움을 
보여주는 사례라고 할 수 있다. 

-전역객체(Global object)는 특수한 객체이다. 모든 객체는 이 전역 객체의 프로퍼티이다. 

    function func(){
        alert('hi');
    }
    func();
    window.func();

->func()와 window.func()는 모두 실행이 된다. 모든 전역변수와 함수는 window 객체의
프로퍼티이며, 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다. 
-ECMAScript에서는 전역객체의 API를 정의해두었는데, 그 외의 API는 호스트 환경에서
필요에 따라서 추가로 정의하고 있다. 웹브라우저 자바스크립트 에서는 alert()라는 
전역 객체의 메소드가 존재하지만 node.js에는 존재하지 않는다. 또한 전역객체의
이름도 호스트 환경에 따라서 다른데, 웹브라우저에서 전역 객체는 window이지만 node.js에서는
global(특정한 객체에 속하지 않는 함수와 속성들)이다. 

-object는 객체의 가장 기본적인 형태를 가지고 있는 객체이다. 아무것도 상속 받지 않는 
순수한 객체로 자바스크립트 에서는 값을 저장하는 기본적인 단위로 object를 사용한다.

    var A = {'a':100, 'b':'80','c':50};
    -> 동시에 자바스크립트의 모든 객체는 Object객체를 상속 받는데, 모든 객체는 Object
    객체의 프로퍼티를 가지고 있다. 

    Object.prototype.contain = function(neddle) {
        for(var name in this){
            if(this[name] === neddle){
                return true;
            }
        }
        return false;
    }
        var o = {'name':'egoing', 'city':'seoul'}
        console.log(o.contain('egoing'));
        var a = ['egoing','leezche','grapittie'];
        console.log(a.contain('leezche'));
    
*/

</script>


<script>
    // var arr = new Array(10, "문자열", false);

    // document.write((typeof arr) + "<br>");    // object
    // document.write((typeof arr[0]) + "<br>"); // number
    // document.write((typeof arr[1]) + "<br>"); // string
    // document.write(typeof arr[2]);            // boolean
    // var chk = [];
    // var input = $('input').val();
    // console.log(input); 
    // for(var i = 1; i < 11; i++ ){
    //     chk.push(i);
    // }
    // console.log(chk);
</script>

<script>
    $(document).ready( function(){
        // 1. input:text name=chk 에 있는 value값을 배열에 담으시오.
        var chk_array =[]; //빈배열 선언 담아서 더하기 위함
        var total = 0; //value값을 담기위한 변수
        var inps = $('input');
        for (var i = 0; i < inps.length; i++) {
            //chk_array.push(inps[i].value);
            chk_array[i] = inps[i].value;
        }
        // console.log(chk_array);  

        // 2. input:text name=chk 에 있는 value값을 전부 더하시오.
        // for (var i = 0; i < inps.length; i++) {
        //     total = total + parseInt(inps[i].value);
        // }
        // alert(total);

        // 3. input:text name=chk 에 있는 value값이 홀수인것만 출력하시오.
        // var total = 0;
        // for (var i = 0; i < inps.length; i++) {

        //     if(i%2 == 0){
        //         console.log(chk_array[i]);
        //     }            
        // }
        // 4. input:text name=chk 에 있는 value값이 짝수인것만 출력하시오.
        // var total = 0;
        // for (var i = 0; i < inps.length; i++) {

        //     if(i%2 != 0){
        //         console.log(chk_array[i]);
        //     }            
        // }

        // 5. input:text name=chk 에 있는 value값이 홀수인것만 더하시오.
        //홀수 1 + 3 + 5 + 7 + 9 = 25
        // var total = 0; 
        // for (var i = 0; i < inps.length; i++) {
        //     if(i%2 != 0){
        //         total = total + parseInt(inps[i].value);
        //     }   
        // }
        // console.log(total);
        // 6. input:text name=chk 에 있는 value값이 짝수인것만 더하시오.
        //짝수 2 + 4 + 6 + 8 + 10 = 30

        // var total = 0; 
        // for (var i = 0; i < inps.length; i++) {
        //     if(i%2 == 0){
        //         total = total + parseInt(inps[i].value);
        //     }   
        // }
        // console.log(total);

    });
    
</script>

<body>
    <!--wrap {-->
    <div class="wrap">
        <input type="text" name="chk[]" id="input" value = "1">
        <input type="text" name="chk[]" id="input" value = "2">
        <input type="text" name="chk[]" id="input" value = "3">
        <input type="text" name="chk[]" id="input" value = "4">
        <input type="text" name="chk[]" id="input" value = "5">
        <input type="text" name="chk[]" id="input" value = "6">
        <input type="text" name="chk[]" id="input" value = "7">
        <input type="text" name="chk[]" id="input" value = "8">
        <input type="text" name="chk[]" id="input" value = "9">
        <input type="text" name="chk[]" id="input" value = "10">
    </div>
    <!--} wrap-->

    <form action="/action_page.php">
        <label for="birthday">Birthday:</label>
        <input type="date" id="birthday" name="birthday">
        <input type="submit" value="Submit">
    </form>
      
</body>
</html>